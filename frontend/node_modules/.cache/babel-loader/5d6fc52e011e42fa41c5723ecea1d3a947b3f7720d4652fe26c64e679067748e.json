{"ast":null,"code":"/**\n * chartjs-chart-graph\n * https://github.com/sgratzl/chartjs-chart-graph\n *\n * Copyright (c) 2019-2023 Samuel Gratzl <sam@sgratzl.com>\n */\n\nimport { LineElement, registry, ScatterController, defaults, Chart, LinearScale, PointElement } from 'chart.js';\nimport { unlistenArrayEvents, listenArrayEvents, clipArea, unclipArea, merge } from 'chart.js/helpers';\nimport { forceSimulation, forceRadial, forceY, forceX, forceManyBody, forceLink, forceCollide, forceCenter } from 'd3-force';\nimport { hierarchy, tree, cluster } from 'd3-hierarchy';\nfunction horizontal(from, to, options) {\n  return {\n    fx: (to.x - from.x) * options.tension,\n    fy: 0,\n    tx: (from.x - to.x) * options.tension,\n    ty: 0\n  };\n}\nfunction vertical(from, to, options) {\n  return {\n    fx: 0,\n    fy: (to.y - from.y) * options.tension,\n    tx: 0,\n    ty: (from.y - to.y) * options.tension\n  };\n}\nfunction radial(from, to, options) {\n  const angleHelper = Math.hypot(to.x - from.x, to.y - from.y) * options.tension;\n  return {\n    fx: Number.isNaN(from.angle) ? 0 : Math.cos(from.angle || 0) * angleHelper,\n    fy: Number.isNaN(from.angle) ? 0 : Math.sin(from.angle || 0) * -angleHelper,\n    tx: Number.isNaN(to.angle) ? 0 : Math.cos(to.angle || 0) * -angleHelper,\n    ty: Number.isNaN(to.angle) ? 0 : Math.sin(to.angle || 0) * angleHelper\n  };\n}\nclass EdgeLine extends LineElement {\n  draw(ctx) {\n    const {\n      options\n    } = this;\n    ctx.save();\n    ctx.lineCap = options.borderCapStyle;\n    ctx.setLineDash(options.borderDash || []);\n    ctx.lineDashOffset = options.borderDashOffset;\n    ctx.lineJoin = options.borderJoinStyle;\n    ctx.lineWidth = options.borderWidth;\n    ctx.strokeStyle = options.borderColor;\n    const orientations = {\n      horizontal,\n      vertical,\n      radial\n    };\n    const layout = orientations[this._orientation] || orientations.horizontal;\n    const renderLine = (from, to) => {\n      const shift = layout(from, to, options);\n      const fromX = {\n        cpx: from.x + shift.fx,\n        cpy: from.y + shift.fy\n      };\n      const toX = {\n        cpx: to.x + shift.tx,\n        cpy: to.y + shift.ty\n      };\n      if (options.stepped === 'middle') {\n        const midpoint = (from.x + to.x) / 2.0;\n        ctx.lineTo(midpoint, from.y);\n        ctx.lineTo(midpoint, to.y);\n        ctx.lineTo(to.x, to.y);\n      } else if (options.stepped === 'after') {\n        ctx.lineTo(from.x, to.y);\n        ctx.lineTo(to.x, to.y);\n      } else if (options.stepped) {\n        ctx.lineTo(to.x, from.y);\n        ctx.lineTo(to.x, to.y);\n      } else if (options.tension) {\n        ctx.bezierCurveTo(fromX.cpx, fromX.cpy, toX.cpx, toX.cpy, to.x, to.y);\n      } else {\n        ctx.lineTo(to.x, to.y);\n      }\n      return to;\n    };\n    const source = this.source.getProps(['x', 'y', 'angle']);\n    const target = this.target.getProps(['x', 'y', 'angle']);\n    const points = this.getProps(['points']).points;\n    ctx.beginPath();\n    let from = source;\n    ctx.moveTo(from.x, from.y);\n    if (points && points.length > 0) {\n      from = points.reduce(renderLine, from);\n    }\n    renderLine(from, target);\n    ctx.stroke();\n    if (options.directed) {\n      const to = target;\n      const shift = layout(from, to, options);\n      const s = options.arrowHeadSize;\n      const offset = options.arrowHeadOffset;\n      ctx.save();\n      ctx.translate(to.x, target.y);\n      if (options.stepped === 'middle') {\n        const midpoint = (from.x + to.x) / 2.0;\n        ctx.rotate(Math.atan2(to.y - to.y, to.x - midpoint));\n      } else if (options.stepped === 'after') {\n        ctx.rotate(Math.atan2(to.y - to.y, to.x - from.x));\n      } else if (options.stepped) {\n        ctx.rotate(Math.atan2(to.y - from.y, to.x - to.x));\n      } else if (options.tension) {\n        const toX = {\n          x: to.x + shift.tx,\n          y: to.y + shift.ty\n        };\n        const f = 0.1;\n        ctx.rotate(Math.atan2(to.y - toX.y * (1 - f) - from.y * f, to.x - toX.x * (1 - f) - from.x * f));\n      } else {\n        ctx.rotate(Math.atan2(to.y - from.y, to.x - from.x));\n      }\n      ctx.translate(-offset, 0);\n      ctx.beginPath();\n      ctx.moveTo(0, 0);\n      ctx.lineTo(-s, -s / 2);\n      ctx.lineTo(-s * 0.9, 0);\n      ctx.lineTo(-s, s / 2);\n      ctx.closePath();\n      ctx.fillStyle = ctx.strokeStyle;\n      ctx.fill();\n      ctx.restore();\n    }\n    ctx.restore();\n  }\n}\nEdgeLine.id = 'edgeLine';\nEdgeLine.defaults = {\n  ...LineElement.defaults,\n  tension: 0,\n  directed: false,\n  arrowHeadSize: 15,\n  arrowHeadOffset: 5\n};\nEdgeLine.defaultRoutes = LineElement.defaultRoutes;\nEdgeLine.descriptors = {\n  _scriptable: true,\n  _indexable: name => name !== 'borderDash'\n};\nfunction interpolateNumber(from, to, factor) {\n  if (from === to) {\n    return to;\n  }\n  return from + (to - from) * factor;\n}\nfunction interpolatorPoint(fromArray, i, to, factor) {\n  const from = fromArray[i] || fromArray[i - 1] || fromArray._source;\n  if (!from) {\n    return to;\n  }\n  const x = interpolateNumber(from.x, to.x, factor);\n  const y = interpolateNumber(from.y, to.y, factor);\n  const angle = Number.isNaN(from.angle) ? interpolateNumber(from.angle, to.angle, factor) : undefined;\n  return {\n    x,\n    y,\n    angle\n  };\n}\nfunction interpolatePoints(from, to, factor) {\n  if (Array.isArray(from) && Array.isArray(to) && to.length > 0) {\n    return to.map((t, i) => interpolatorPoint(from, i, t, factor));\n  }\n  return to;\n}\nfunction patchController(type, config, controller, elements = [], scales = []) {\n  registry.addControllers(controller);\n  if (Array.isArray(elements)) {\n    registry.addElements(...elements);\n  } else {\n    registry.addElements(elements);\n  }\n  if (Array.isArray(scales)) {\n    registry.addScales(...scales);\n  } else {\n    registry.addScales(scales);\n  }\n  const c = config;\n  c.type = type;\n  return c;\n}\nclass GraphController extends ScatterController {\n  constructor() {\n    super(...arguments);\n    this._scheduleResyncLayoutId = -1;\n    this._edgeListener = {\n      _onDataPush: (...args) => {\n        const count = args.length;\n        const start = this.getDataset().edges.length - count;\n        const parsed = this._cachedMeta._parsedEdges;\n        args.forEach(edge => {\n          parsed.push(this._parseDefinedEdge(edge));\n        });\n        this._insertEdgeElements(start, count);\n      },\n      _onDataPop: () => {\n        this._cachedMeta.edges.pop();\n        this._cachedMeta._parsedEdges.pop();\n        this._scheduleResyncLayout();\n      },\n      _onDataShift: () => {\n        this._cachedMeta.edges.shift();\n        this._cachedMeta._parsedEdges.shift();\n        this._scheduleResyncLayout();\n      },\n      _onDataSplice: (start, count, ...args) => {\n        this._cachedMeta.edges.splice(start, count);\n        this._cachedMeta._parsedEdges.splice(start, count);\n        if (args.length > 0) {\n          const parsed = this._cachedMeta._parsedEdges;\n          parsed.splice(start, 0, ...args.map(edge => this._parseDefinedEdge(edge)));\n          this._insertEdgeElements(start, args.length);\n        } else {\n          this._scheduleResyncLayout();\n        }\n      },\n      _onDataUnshift: (...args) => {\n        const parsed = this._cachedMeta._parsedEdges;\n        parsed.unshift(...args.map(edge => this._parseDefinedEdge(edge)));\n        this._insertEdgeElements(0, args.length);\n      }\n    };\n  }\n  initialize() {\n    const type = this._type;\n    const defaultConfig = defaults.datasets[type];\n    this.edgeElementType = registry.getElement(defaultConfig.edgeElementType);\n    super.initialize();\n    this.enableOptionSharing = true;\n    this._scheduleResyncLayout();\n  }\n  parse(start, count) {\n    const meta = this._cachedMeta;\n    const data = this._data;\n    const {\n      iScale,\n      vScale\n    } = meta;\n    for (let i = 0; i < count; i += 1) {\n      const index = i + start;\n      const d = data[index];\n      const v = meta._parsed[index] || {};\n      if (d && typeof d.x === 'number') {\n        v.x = d.x;\n      }\n      if (d && typeof d.y === 'number') {\n        v.y = d.y;\n      }\n      meta._parsed[index] = v;\n    }\n    if (meta._parsed.length > data.length) {\n      meta._parsed.splice(data.length, meta._parsed.length - data.length);\n    }\n    this._cachedMeta._sorted = false;\n    iScale._dataLimitsCached = false;\n    vScale._dataLimitsCached = false;\n    this._parseEdges();\n  }\n  reset() {\n    this.resetLayout();\n    super.reset();\n  }\n  update(mode) {\n    super.update(mode);\n    const meta = this._cachedMeta;\n    const edges = meta.edges || [];\n    this.updateEdgeElements(edges, 0, mode);\n  }\n  _destroy() {\n    ScatterController.prototype._destroy.call(this);\n    if (this._edges) {\n      unlistenArrayEvents(this._edges, this._edgeListener);\n    }\n    this.stopLayout();\n  }\n  updateEdgeElements(edges, start, mode) {\n    var _a, _b, _c;\n    const bak = {\n      _cachedDataOpts: this._cachedDataOpts,\n      dataElementType: this.dataElementType,\n      _sharedOptions: this._sharedOptions\n    };\n    this._cachedDataOpts = {};\n    this.dataElementType = this.edgeElementType;\n    this._sharedOptions = this._edgeSharedOptions;\n    const dataset = this.getDataset();\n    const meta = this._cachedMeta;\n    const nodeElements = meta.data;\n    const data = this._cachedMeta._parsedEdges;\n    this.getContext(-1, false, mode);\n    this.getDataset = () => {\n      return new Proxy(dataset, {\n        get(obj, prop) {\n          var _a;\n          return prop === 'data' ? (_a = obj.edges) !== null && _a !== void 0 ? _a : [] : obj[prop];\n        }\n      });\n    };\n    this.getParsed = index => {\n      return data[index];\n    };\n    meta.data = meta.edges;\n    const reset = mode === 'reset';\n    const firstOpts = this.resolveDataElementOptions(start, mode);\n    const dummyShared = {};\n    const sharedOptions = (_a = this.getSharedOptions(firstOpts)) !== null && _a !== void 0 ? _a : dummyShared;\n    const includeOptions = this.includeOptions(mode, sharedOptions);\n    const {\n      xScale,\n      yScale\n    } = meta;\n    const base = {\n      x: (_b = xScale === null || xScale === void 0 ? void 0 : xScale.getBasePixel()) !== null && _b !== void 0 ? _b : 0,\n      y: (_c = yScale === null || yScale === void 0 ? void 0 : yScale.getBasePixel()) !== null && _c !== void 0 ? _c : 0\n    };\n    function copyPoint(point) {\n      var _a, _b;\n      const x = reset ? base.x : (_a = xScale === null || xScale === void 0 ? void 0 : xScale.getPixelForValue(point.x, 0)) !== null && _a !== void 0 ? _a : 0;\n      const y = reset ? base.y : (_b = yScale === null || yScale === void 0 ? void 0 : yScale.getPixelForValue(point.y, 0)) !== null && _b !== void 0 ? _b : 0;\n      return {\n        x,\n        y,\n        angle: point.angle\n      };\n    }\n    for (let i = 0; i < edges.length; i += 1) {\n      const edge = edges[i];\n      const index = start + i;\n      const parsed = data[index];\n      const properties = {\n        source: nodeElements[parsed.source],\n        target: nodeElements[parsed.target],\n        points: Array.isArray(parsed.points) ? parsed.points.map(p => copyPoint(p)) : []\n      };\n      properties.points._source = nodeElements[parsed.source];\n      if (includeOptions) {\n        if (sharedOptions !== dummyShared) {\n          properties.options = sharedOptions;\n        } else {\n          properties.options = this.resolveDataElementOptions(index, mode);\n        }\n      }\n      this.updateEdgeElement(edge, index, properties, mode);\n    }\n    this.updateSharedOptions(sharedOptions, mode, firstOpts);\n    this._edgeSharedOptions = this._sharedOptions;\n    Object.assign(this, bak);\n    delete this.getDataset;\n    delete this.getParsed;\n    meta.data = nodeElements;\n  }\n  updateEdgeElement(edge, index, properties, mode) {\n    super.updateElement(edge, index, properties, mode);\n  }\n  updateElement(point, index, properties, mode) {\n    var _a;\n    if (mode === 'reset') {\n      const {\n        xScale\n      } = this._cachedMeta;\n      properties.x = (_a = xScale === null || xScale === void 0 ? void 0 : xScale.getBasePixel()) !== null && _a !== void 0 ? _a : 0;\n    }\n    super.updateElement(point, index, properties, mode);\n  }\n  resolveNodeIndex(nodes, ref) {\n    if (typeof ref === 'number') {\n      return ref;\n    }\n    if (typeof ref === 'string') {\n      const labels = this.chart.data.labels;\n      return labels.indexOf(ref);\n    }\n    const nIndex = nodes.indexOf(ref);\n    if (nIndex >= 0) {\n      return nIndex;\n    }\n    const data = this.getDataset().data;\n    const index = data.indexOf(ref);\n    if (index >= 0) {\n      return index;\n    }\n    console.warn('cannot resolve edge ref', ref);\n    return -1;\n  }\n  buildOrUpdateElements() {\n    const dataset = this.getDataset();\n    const edges = dataset.edges || [];\n    if (this._edges !== edges) {\n      if (this._edges) {\n        unlistenArrayEvents(this._edges, this._edgeListener);\n      }\n      if (edges && Object.isExtensible(edges)) {\n        listenArrayEvents(edges, this._edgeListener);\n      }\n      this._edges = edges;\n    }\n    super.buildOrUpdateElements();\n  }\n  draw() {\n    const meta = this._cachedMeta;\n    const edges = this._cachedMeta.edges || [];\n    const elements = meta.data || [];\n    const area = this.chart.chartArea;\n    const ctx = this._ctx;\n    if (edges.length > 0) {\n      clipArea(ctx, area);\n      edges.forEach(edge => edge.draw.call(edge, ctx, area));\n      unclipArea(ctx);\n    }\n    elements.forEach(elem => elem.draw.call(elem, ctx, area));\n  }\n  _resyncElements() {\n    ScatterController.prototype._resyncElements.call(this);\n    const meta = this._cachedMeta;\n    const edges = meta._parsedEdges;\n    const metaEdges = meta.edges || (meta.edges = []);\n    const numMeta = metaEdges.length;\n    const numData = edges.length;\n    if (numData < numMeta) {\n      metaEdges.splice(numData, numMeta - numData);\n      this._scheduleResyncLayout();\n    } else if (numData > numMeta) {\n      this._insertEdgeElements(numMeta, numData - numMeta);\n    }\n  }\n  getTreeRootIndex() {\n    const ds = this.getDataset();\n    const nodes = ds.data;\n    if (ds.derivedEdges) {\n      return nodes.findIndex(d => d.parent == null);\n    }\n    const edges = this._cachedMeta._parsedEdges || [];\n    const nodeIndices = new Set(nodes.map((_, i) => i));\n    edges.forEach(edge => {\n      nodeIndices.delete(edge.target);\n    });\n    return Array.from(nodeIndices)[0];\n  }\n  getTreeRoot() {\n    const index = this.getTreeRootIndex();\n    const p = this.getParsed(index);\n    p.index = index;\n    return p;\n  }\n  getTreeChildren(node) {\n    var _a;\n    const edges = this._cachedMeta._parsedEdges;\n    const index = (_a = node.index) !== null && _a !== void 0 ? _a : 0;\n    return edges.filter(d => d.source === index).map(d => {\n      const p = this.getParsed(d.target);\n      p.index = d.target;\n      return p;\n    });\n  }\n  _parseDefinedEdge(edge) {\n    const ds = this.getDataset();\n    const {\n      data\n    } = ds;\n    return {\n      source: this.resolveNodeIndex(data, edge.source),\n      target: this.resolveNodeIndex(data, edge.target),\n      points: []\n    };\n  }\n  _parseEdges() {\n    const ds = this.getDataset();\n    const data = ds.data;\n    const meta = this._cachedMeta;\n    if (ds.edges) {\n      const edges = ds.edges.map(edge => this._parseDefinedEdge(edge));\n      meta._parsedEdges = edges;\n      return edges;\n    }\n    const edges = [];\n    meta._parsedEdges = edges;\n    data.forEach((node, i) => {\n      if (node.parent != null) {\n        const parent = this.resolveNodeIndex(data, node.parent);\n        edges.push({\n          source: parent,\n          target: i,\n          points: []\n        });\n      }\n    });\n    return edges;\n  }\n  addElements() {\n    super.addElements();\n    const meta = this._cachedMeta;\n    const edges = this._parseEdges();\n    const metaData = new Array(edges.length);\n    meta.edges = metaData;\n    for (let i = 0; i < edges.length; i += 1) {\n      metaData[i] = new this.edgeElementType();\n    }\n  }\n  _resyncEdgeElements() {\n    const meta = this._cachedMeta;\n    const edges = this._parseEdges();\n    const metaData = meta.edges || (meta.edges = []);\n    for (let i = 0; i < edges.length; i += 1) {\n      metaData[i] = metaData[i] || new this.edgeElementType();\n    }\n    if (edges.length < metaData.length) {\n      metaData.splice(edges.length, metaData.length);\n    }\n  }\n  _insertElements(start, count) {\n    ScatterController.prototype._insertElements.call(this, start, count);\n    if (count > 0) {\n      this._resyncEdgeElements();\n    }\n  }\n  _removeElements(start, count) {\n    ScatterController.prototype._removeElements.call(this, start, count);\n    if (count > 0) {\n      this._resyncEdgeElements();\n    }\n  }\n  _insertEdgeElements(start, count) {\n    const elements = [];\n    for (let i = 0; i < count; i += 1) {\n      elements.push(new this.edgeElementType());\n    }\n    this._cachedMeta.edges.splice(start, 0, ...elements);\n    this.updateEdgeElements(elements, start, 'reset');\n    this._scheduleResyncLayout();\n  }\n  reLayout() {}\n  resetLayout() {}\n  stopLayout() {}\n  _scheduleResyncLayout() {\n    if (this._scheduleResyncLayoutId != null && this._scheduleResyncLayoutId >= 0) {\n      return;\n    }\n    this._scheduleResyncLayoutId = requestAnimationFrame(() => {\n      this._scheduleResyncLayoutId = -1;\n      this.resyncLayout();\n    });\n  }\n  resyncLayout() {}\n}\nGraphController.id = 'graph';\nGraphController.defaults = merge({}, [ScatterController.defaults, {\n  clip: 10,\n  animations: {\n    points: {\n      fn: interpolatePoints,\n      properties: ['points']\n    }\n  },\n  edgeElementType: EdgeLine.id\n}]);\nGraphController.overrides = merge({}, [ScatterController.overrides, {\n  layout: {\n    padding: 10\n  },\n  scales: {\n    x: {\n      display: false,\n      ticks: {\n        maxTicksLimit: 2,\n        precision: 100,\n        minRotation: 0,\n        maxRotation: 0\n      }\n    },\n    y: {\n      display: false,\n      ticks: {\n        maxTicksLimit: 2,\n        precision: 100,\n        minRotation: 0,\n        maxRotation: 0\n      }\n    }\n  },\n  plugins: {\n    tooltip: {\n      callbacks: {\n        label(item) {\n          var _a, _b;\n          return (_b = (_a = item.chart.data) === null || _a === void 0 ? void 0 : _a.labels) === null || _b === void 0 ? void 0 : _b[item.dataIndex];\n        }\n      }\n    }\n  }\n}]);\nclass GraphChart extends Chart {\n  constructor(item, config) {\n    super(item, patchController('graph', config, GraphController, [EdgeLine, PointElement], LinearScale));\n  }\n}\nGraphChart.id = GraphController.id;\nclass ForceDirectedGraphController extends GraphController {\n  constructor(chart, datasetIndex) {\n    super(chart, datasetIndex);\n    this._animTimer = -1;\n    this._simulation = forceSimulation().on('tick', () => {\n      if (this.chart.canvas && this._animTimer !== -2) {\n        this._copyPosition();\n        this.chart.render();\n      } else {\n        this._simulation.stop();\n      }\n    }).on('end', () => {\n      if (this.chart.canvas && this._animTimer !== -2) {\n        this._copyPosition();\n        this.chart.render();\n        this.chart.update('default');\n      }\n    });\n    const sim = this.options.simulation;\n    const fs = {\n      center: forceCenter,\n      collide: forceCollide,\n      link: forceLink,\n      manyBody: forceManyBody,\n      x: forceX,\n      y: forceY,\n      radial: forceRadial\n    };\n    Object.keys(fs).forEach(key => {\n      const options = sim.forces[key];\n      if (!options) {\n        return;\n      }\n      const f = fs[key]();\n      if (typeof options !== 'boolean') {\n        Object.keys(options).forEach(attr => {\n          f[attr](options[attr]);\n        });\n      }\n      this._simulation.force(key, f);\n    });\n    this._simulation.stop();\n  }\n  _destroy() {\n    if (this._animTimer >= 0) {\n      cancelAnimationFrame(this._animTimer);\n    }\n    this._animTimer = -2;\n    return super._destroy();\n  }\n  _copyPosition() {\n    const nodes = this._cachedMeta._parsed;\n    const minmax = nodes.reduce((acc, v) => {\n      const s = v._sim;\n      if (!s || s.x == null || s.y == null) {\n        return acc;\n      }\n      if (s.x < acc.minX) {\n        acc.minX = s.x;\n      }\n      if (s.x > acc.maxX) {\n        acc.maxX = s.x;\n      }\n      if (s.y < acc.minY) {\n        acc.minY = s.y;\n      }\n      if (s.y > acc.maxY) {\n        acc.maxY = s.y;\n      }\n      return acc;\n    }, {\n      minX: Number.POSITIVE_INFINITY,\n      maxX: Number.NEGATIVE_INFINITY,\n      minY: Number.POSITIVE_INFINITY,\n      maxY: Number.NEGATIVE_INFINITY\n    });\n    const rescaleX = v => (v - minmax.minX) / (minmax.maxX - minmax.minX) * 2 - 1;\n    const rescaleY = v => (v - minmax.minY) / (minmax.maxY - minmax.minY) * 2 - 1;\n    nodes.forEach(node => {\n      var _a, _b;\n      if (node._sim) {\n        node.x = rescaleX((_a = node._sim.x) !== null && _a !== void 0 ? _a : 0);\n        node.y = rescaleY((_b = node._sim.y) !== null && _b !== void 0 ? _b : 0);\n      }\n    });\n    const {\n      xScale,\n      yScale\n    } = this._cachedMeta;\n    const elems = this._cachedMeta.data;\n    elems.forEach((elem, i) => {\n      var _a, _b;\n      const parsed = nodes[i];\n      Object.assign(elem, {\n        x: (_a = xScale === null || xScale === void 0 ? void 0 : xScale.getPixelForValue(parsed.x, i)) !== null && _a !== void 0 ? _a : 0,\n        y: (_b = yScale === null || yScale === void 0 ? void 0 : yScale.getPixelForValue(parsed.y, i)) !== null && _b !== void 0 ? _b : 0,\n        skip: false\n      });\n    });\n  }\n  resetLayout() {\n    super.resetLayout();\n    this._simulation.stop();\n    const nodes = this._cachedMeta._parsed.map((node, i) => {\n      const simNode = {\n        ...node\n      };\n      simNode.index = i;\n      node._sim = simNode;\n      if (!node.reset) {\n        return simNode;\n      }\n      delete simNode.x;\n      delete simNode.y;\n      delete simNode.vx;\n      delete simNode.vy;\n      return simNode;\n    });\n    this._simulation.nodes(nodes);\n    this._simulation.alpha(1).restart();\n  }\n  resyncLayout() {\n    super.resyncLayout();\n    this._simulation.stop();\n    const meta = this._cachedMeta;\n    const nodes = meta._parsed.map((node, i) => {\n      const simNode = {\n        ...node\n      };\n      simNode.index = i;\n      node._sim = simNode;\n      if (simNode.x === null) {\n        delete simNode.x;\n      }\n      if (simNode.y === null) {\n        delete simNode.y;\n      }\n      if (simNode.x == null && simNode.y == null) {\n        node.reset = true;\n      }\n      return simNode;\n    });\n    const link = this._simulation.force('link');\n    if (link) {\n      link.links([]);\n    }\n    this._simulation.nodes(nodes);\n    if (link) {\n      link.links((meta._parsedEdges || []).map(l => ({\n        ...l\n      })));\n    }\n    if (this.options.simulation.initialIterations > 0) {\n      this._simulation.alpha(1);\n      this._simulation.tick(this.options.simulation.initialIterations);\n      this._copyPosition();\n      if (this.options.simulation.autoRestart) {\n        this._simulation.restart();\n      } else if (this.chart.canvas != null && this._animTimer !== -2) {\n        const chart = this.chart;\n        this._animTimer = requestAnimationFrame(() => {\n          if (chart.canvas) {\n            chart.update();\n          }\n        });\n      }\n    } else if (this.options.simulation.autoRestart && this.chart.canvas != null && this._animTimer !== -2) {\n      this._simulation.alpha(1).restart();\n    }\n  }\n  reLayout() {\n    this._simulation.alpha(1).restart();\n  }\n  stopLayout() {\n    super.stopLayout();\n    this._simulation.stop();\n  }\n}\nForceDirectedGraphController.id = 'forceDirectedGraph';\nForceDirectedGraphController.defaults = merge({}, [GraphController.defaults, {\n  animation: false,\n  simulation: {\n    initialIterations: 0,\n    autoRestart: true,\n    forces: {\n      center: true,\n      collide: false,\n      link: true,\n      manyBody: true,\n      x: false,\n      y: false,\n      radial: false\n    }\n  }\n}]);\nForceDirectedGraphController.overrides = merge({}, [GraphController.overrides, {\n  scales: {\n    x: {\n      min: -1,\n      max: 1\n    },\n    y: {\n      min: -1,\n      max: 1\n    }\n  }\n}]);\nclass ForceDirectedGraphChart extends Chart {\n  constructor(item, config) {\n    super(item, patchController('forceDirectedGraph', config, ForceDirectedGraphController, [EdgeLine, PointElement], LinearScale));\n  }\n}\nForceDirectedGraphChart.id = ForceDirectedGraphController.id;\nclass DendrogramController extends GraphController {\n  constructor() {\n    super(...arguments);\n    this._animTimer = -1;\n  }\n  updateEdgeElement(line, index, properties, mode) {\n    properties._orientation = this.options.tree.orientation;\n    super.updateEdgeElement(line, index, properties, mode);\n  }\n  _destroy() {\n    if (this._animTimer >= 0) {\n      cancelAnimationFrame(this._animTimer);\n    }\n    this._animTimer = -2;\n    return super._destroy();\n  }\n  updateElement(point, index, properties, mode) {\n    if (index != null) {\n      properties.angle = this.getParsed(index).angle;\n    }\n    super.updateElement(point, index, properties, mode);\n  }\n  resyncLayout() {\n    const meta = this._cachedMeta;\n    meta.root = hierarchy(this.getTreeRoot(), d => this.getTreeChildren(d)).count().sort((a, b) => {\n      var _a, _b;\n      return b.height - a.height || ((_a = b.data.index) !== null && _a !== void 0 ? _a : 0) - ((_b = a.data.index) !== null && _b !== void 0 ? _b : 0);\n    });\n    this.doLayout(meta.root);\n    super.resyncLayout();\n  }\n  reLayout(newOptions = {}) {\n    if (newOptions) {\n      Object.assign(this.options.tree, newOptions);\n      const ds = this.getDataset();\n      if (ds.tree) {\n        Object.assign(ds.tree, newOptions);\n      } else {\n        ds.tree = newOptions;\n      }\n    }\n    this.doLayout(this._cachedMeta.root);\n  }\n  doLayout(root) {\n    const options = this.options.tree;\n    const layout = options.mode === 'tree' ? tree() : cluster();\n    if (options.orientation === 'radial') {\n      layout.size([Math.PI * 2, 1]);\n    } else {\n      layout.size([2, 2]);\n    }\n    const orientation = {\n      horizontal: d => {\n        d.data.x = d.y - 1;\n        d.data.y = -d.x + 1;\n      },\n      vertical: d => {\n        d.data.x = d.x - 1;\n        d.data.y = -d.y + 1;\n      },\n      radial: d => {\n        d.data.x = Math.cos(d.x) * d.y;\n        d.data.y = Math.sin(d.x) * d.y;\n        d.data.angle = d.y === 0 ? Number.NaN : d.x;\n      }\n    };\n    layout(root).each(orientation[options.orientation] || orientation.horizontal);\n    const chart = this.chart;\n    if (this._animTimer !== -2) {\n      this._animTimer = requestAnimationFrame(() => {\n        if (chart.canvas) {\n          chart.update();\n        }\n      });\n    }\n  }\n}\nDendrogramController.id = 'dendrogram';\nDendrogramController.defaults = merge({}, [GraphController.defaults, {\n  tree: {\n    mode: 'dendrogram',\n    orientation: 'horizontal'\n  },\n  animations: {\n    numbers: {\n      type: 'number',\n      properties: ['x', 'y', 'angle', 'radius', 'rotation', 'borderWidth']\n    }\n  },\n  tension: 0.4\n}]);\nDendrogramController.overrides = merge({}, [GraphController.overrides, {\n  scales: {\n    x: {\n      min: -1,\n      max: 1\n    },\n    y: {\n      min: -1,\n      max: 1\n    }\n  }\n}]);\nclass DendrogramChart extends Chart {\n  constructor(item, config) {\n    super(item, patchController('dendrogram', config, DendrogramController, [EdgeLine, PointElement], LinearScale));\n  }\n}\nDendrogramChart.id = DendrogramController.id;\nclass DendogramController extends DendrogramController {}\nDendogramController.id = 'dendogram';\nDendogramController.defaults = merge({}, [DendrogramController.defaults, {\n  tree: {\n    mode: 'dendrogram'\n  }\n}]);\nconst DendogramChart = DendrogramChart;\nclass TreeController extends DendrogramController {}\nTreeController.id = 'tree';\nTreeController.defaults = merge({}, [DendrogramController.defaults, {\n  tree: {\n    mode: 'tree'\n  }\n}]);\nTreeController.overrides = DendrogramController.overrides;\nclass TreeChart extends Chart {\n  constructor(item, config) {\n    super(item, patchController('tree', config, TreeController, [EdgeLine, PointElement], LinearScale));\n  }\n}\nTreeChart.id = TreeController.id;\nexport { DendogramChart, DendogramController, DendrogramChart, DendrogramController, EdgeLine, ForceDirectedGraphChart, ForceDirectedGraphController, GraphChart, GraphController, TreeChart, TreeController };","map":{"version":3,"names":["horizontal","from","to","options","fx","x","tension","fy","tx","ty","vertical","y","radial","angleHelper","Math","hypot","Number","isNaN","angle","cos","sin","EdgeLine","LineElement","draw","ctx","save","lineCap","borderCapStyle","setLineDash","borderDash","lineDashOffset","borderDashOffset","lineJoin","borderJoinStyle","lineWidth","borderWidth","strokeStyle","borderColor","orientations","layout","_orientation","renderLine","shift","fromX","cpx","cpy","toX","stepped","midpoint","lineTo","bezierCurveTo","source","getProps","target","points","beginPath","moveTo","length","reduce","stroke","directed","s","arrowHeadSize","offset","arrowHeadOffset","translate","rotate","atan2","f","closePath","fillStyle","fill","restore","id","defaults","defaultRoutes","descriptors","_scriptable","_indexable","name","interpolateNumber","factor","interpolatorPoint","fromArray","i","_source","undefined","interpolatePoints","Array","isArray","map","t","patchController","type","config","controller","elements","scales","registry","addControllers","addElements","addScales","c","GraphController","ScatterController","constructor","_scheduleResyncLayoutId","_edgeListener","_onDataPush","args","count","start","getDataset","edges","parsed","_cachedMeta","_parsedEdges","forEach","edge","push","_parseDefinedEdge","_insertEdgeElements","_onDataPop","pop","_scheduleResyncLayout","_onDataShift","_onDataSplice","splice","_onDataUnshift","unshift","initialize","_type","defaultConfig","datasets","edgeElementType","getElement","enableOptionSharing","parse","meta","data","_data","iScale","vScale","index","d","v","_parsed","_sorted","_dataLimitsCached","_parseEdges","reset","resetLayout","update","mode","updateEdgeElements","_destroy","prototype","call","_edges","unlistenArrayEvents","stopLayout","bak","_cachedDataOpts","dataElementType","_sharedOptions","_edgeSharedOptions","dataset","nodeElements","getContext","Proxy","get","obj","prop","_a","getParsed","firstOpts","resolveDataElementOptions","dummyShared","sharedOptions","getSharedOptions","includeOptions","xScale","yScale","base","_b","getBasePixel","_c","copyPoint","point","getPixelForValue","properties","p","updateEdgeElement","updateSharedOptions","Object","assign","updateElement","resolveNodeIndex","nodes","ref","labels","chart","indexOf","nIndex","console","warn","buildOrUpdateElements","isExtensible","listenArrayEvents","area","chartArea","_ctx","clipArea","unclipArea","elem","_resyncElements","metaEdges","numMeta","numData","getTreeRootIndex","ds","derivedEdges","findIndex","parent","nodeIndices","Set","_","delete","getTreeRoot","getTreeChildren","node","filter","metaData","_resyncEdgeElements","_insertElements","_removeElements","reLayout","requestAnimationFrame","resyncLayout","merge","clip","animations","fn","overrides","padding","display","ticks","maxTicksLimit","precision","minRotation","maxRotation","plugins","tooltip","callbacks","label","item","dataIndex","GraphChart","Chart","PointElement","LinearScale","ForceDirectedGraphController","datasetIndex","_animTimer","_simulation","forceSimulation","on","canvas","_copyPosition","render","stop","sim","simulation","fs","center","forceCenter","collide","forceCollide","link","forceLink","manyBody","forceManyBody","forceX","forceY","forceRadial","keys","key","forces","attr","force","cancelAnimationFrame","minmax","acc","_sim","minX","maxX","minY","maxY","POSITIVE_INFINITY","NEGATIVE_INFINITY","rescaleX","rescaleY","elems","skip","simNode","vx","vy","alpha","restart","links","l","initialIterations","tick","autoRestart","animation","min","max","ForceDirectedGraphChart","DendrogramController","line","tree","orientation","root","hierarchy","sort","a","b","height","doLayout","newOptions","cluster","size","PI","NaN","each","numbers","DendrogramChart","DendogramController","DendogramChart","TreeController","TreeChart"],"sources":["/Users/ayush/Desktop/Projects/github-code-visualise/frontend/node_modules/chartjs-chart-graph/src/elements/EdgeLine.ts","/Users/ayush/Desktop/Projects/github-code-visualise/frontend/node_modules/chartjs-chart-graph/src/controllers/interpolatePoints.ts","/Users/ayush/Desktop/Projects/github-code-visualise/frontend/node_modules/chartjs-chart-graph/src/controllers/patchController.ts","/Users/ayush/Desktop/Projects/github-code-visualise/frontend/node_modules/chartjs-chart-graph/src/controllers/GraphController.ts","/Users/ayush/Desktop/Projects/github-code-visualise/frontend/node_modules/chartjs-chart-graph/src/controllers/ForceDirectedGraphController.ts","/Users/ayush/Desktop/Projects/github-code-visualise/frontend/node_modules/chartjs-chart-graph/src/controllers/DendrogramController.ts","/Users/ayush/Desktop/Projects/github-code-visualise/frontend/node_modules/chartjs-chart-graph/src/controllers/TreeController.ts"],"sourcesContent":["import {\n  ChartType,\n  LineElement,\n  LineOptions,\n  PointElement,\n  ScriptableAndArrayOptions,\n  ScriptableContext,\n} from 'chart.js';\n\nfunction horizontal(from: { x: number }, to: { x: number }, options: { tension: number }) {\n  return {\n    fx: (to.x - from.x) * options.tension,\n    fy: 0,\n    tx: (from.x - to.x) * options.tension,\n    ty: 0,\n  };\n}\n\nfunction vertical(from: { y: number }, to: { y: number }, options: { tension: number }) {\n  return {\n    fx: 0,\n    fy: (to.y - from.y) * options.tension,\n    tx: 0,\n    ty: (from.y - to.y) * options.tension,\n  };\n}\n\nfunction radial(\n  from: { x: number; angle?: number; y: number },\n  to: { x: number; angle?: number; y: number },\n  options: { tension: number }\n) {\n  const angleHelper = Math.hypot(to.x - from.x, to.y - from.y) * options.tension;\n  return {\n    fx: Number.isNaN(from.angle) ? 0 : Math.cos(from.angle || 0) * angleHelper,\n    fy: Number.isNaN(from.angle) ? 0 : Math.sin(from.angle || 0) * -angleHelper,\n    tx: Number.isNaN(to.angle) ? 0 : Math.cos(to.angle || 0) * -angleHelper,\n    ty: Number.isNaN(to.angle) ? 0 : Math.sin(to.angle || 0) * angleHelper,\n  };\n}\n\nexport interface IEdgeLineOptions extends LineOptions {\n  directed: boolean;\n  arrowHeadSize: number;\n  arrowHeadOffset: number;\n}\n\nexport interface IEdgeLineProps extends LineOptions {\n  points: { x: number; y: number }[];\n}\n\nexport class EdgeLine extends LineElement {\n  /**\n   * @hidden\n   */\n  declare _orientation: 'vertical' | 'radial' | 'horizontal';\n\n  /**\n   * @hidden\n   */\n  declare source: PointElement;\n\n  /**\n   * @hidden\n   */\n  declare target: PointElement;\n\n  /**\n   * @hidden\n   */\n  declare options: IEdgeLineOptions;\n\n  /**\n   * @hidden\n   */\n  draw(ctx: CanvasRenderingContext2D): void {\n    const { options } = this;\n\n    ctx.save();\n\n    // Stroke Line Options\n    ctx.lineCap = options.borderCapStyle;\n    ctx.setLineDash(options.borderDash || []);\n    ctx.lineDashOffset = options.borderDashOffset;\n    ctx.lineJoin = options.borderJoinStyle;\n    ctx.lineWidth = options.borderWidth;\n    ctx.strokeStyle = options.borderColor;\n\n    const orientations = {\n      horizontal,\n      vertical,\n      radial,\n    };\n    const layout = orientations[this._orientation] || orientations.horizontal;\n\n    const renderLine = (\n      from: { x: number; y: number; angle?: number },\n      to: { x: number; y: number; angle?: number }\n    ) => {\n      const shift = layout(from, to, options);\n\n      const fromX = {\n        cpx: from.x + shift.fx,\n        cpy: from.y + shift.fy,\n      };\n      const toX = {\n        cpx: to.x + shift.tx,\n        cpy: to.y + shift.ty,\n      };\n\n      // Line to next point\n      if (options.stepped === 'middle') {\n        const midpoint = (from.x + to.x) / 2.0;\n        ctx.lineTo(midpoint, from.y);\n        ctx.lineTo(midpoint, to.y);\n        ctx.lineTo(to.x, to.y);\n      } else if (options.stepped === 'after') {\n        ctx.lineTo(from.x, to.y);\n        ctx.lineTo(to.x, to.y);\n      } else if (options.stepped) {\n        ctx.lineTo(to.x, from.y);\n        ctx.lineTo(to.x, to.y);\n      } else if (options.tension) {\n        ctx.bezierCurveTo(fromX.cpx, fromX.cpy, toX.cpx, toX.cpy, to.x, to.y);\n      } else {\n        ctx.lineTo(to.x, to.y);\n      }\n      return to;\n    };\n\n    const source = this.source.getProps(['x', 'y', 'angle']) as { x: number; y: number; angle?: number };\n    const target = this.target.getProps(['x', 'y', 'angle']) as { x: number; y: number; angle?: number };\n    const points = (this.getProps(['points'] as any) as any).points as {\n      x: number;\n      y: number;\n      angle: number;\n    }[];\n\n    // Stroke Line\n    ctx.beginPath();\n\n    let from = source;\n    ctx.moveTo(from.x, from.y);\n    if (points && points.length > 0) {\n      from = points.reduce(renderLine, from);\n    }\n    renderLine(from, target);\n\n    ctx.stroke();\n\n    if (options.directed) {\n      const to = target;\n      // compute the rotation based on from and to\n      const shift = layout(from, to, options);\n      const s = options.arrowHeadSize;\n      const offset = options.arrowHeadOffset;\n      ctx.save();\n      ctx.translate(to.x, target.y);\n      if (options.stepped === 'middle') {\n        const midpoint = (from.x + to.x) / 2.0;\n        ctx.rotate(Math.atan2(to.y - to.y, to.x - midpoint));\n      } else if (options.stepped === 'after') {\n        ctx.rotate(Math.atan2(to.y - to.y, to.x - from.x));\n      } else if (options.stepped) {\n        ctx.rotate(Math.atan2(to.y - from.y, to.x - to.x));\n      } else if (options.tension) {\n        const toX = {\n          x: to.x + shift.tx,\n          y: to.y + shift.ty,\n        };\n        const f = 0.1;\n        ctx.rotate(Math.atan2(to.y - toX.y * (1 - f) - from.y * f, to.x - toX.x * (1 - f) - from.x * f));\n      } else {\n        ctx.rotate(Math.atan2(to.y - from.y, to.x - from.x));\n      }\n      ctx.translate(-offset, 0);\n      ctx.beginPath();\n\n      ctx.moveTo(0, 0);\n      ctx.lineTo(-s, -s / 2);\n      ctx.lineTo(-s * 0.9, 0);\n      ctx.lineTo(-s, s / 2);\n      ctx.closePath();\n      ctx.fillStyle = ctx.strokeStyle;\n      ctx.fill();\n\n      ctx.restore();\n    }\n\n    ctx.restore();\n\n    // point helper\n    // ctx.save();\n    // ctx.strokeStyle = 'blue';\n    // ctx.beginPath();\n    // ctx.moveTo(from.x, from.y);\n    // ctx.lineTo(from.x + shift.fx, from.y + shift.fy, 3, 3);\n    // ctx.stroke();\n    // ctx.strokeStyle = 'red';\n    // ctx.beginPath();\n    // ctx.moveTo(to.x, to.y);\n    // ctx.lineTo(to.x + shift.tx, to.y + shift.ty, 3, 3);\n    // ctx.stroke();\n    // ctx.restore();\n  }\n\n  static readonly id = 'edgeLine';\n\n  /**\n   * @hidden\n   */\n  static readonly defaults: any = /* #__PURE__ */ {\n    ...LineElement.defaults,\n    tension: 0,\n    directed: false,\n    arrowHeadSize: 15,\n    arrowHeadOffset: 5,\n  };\n\n  /**\n   * @hidden\n   */\n  static readonly defaultRoutes = LineElement.defaultRoutes;\n\n  /**\n   * @hidden\n   */\n  static readonly descriptors = /* #__PURE__ */ {\n    _scriptable: true,\n    _indexable: (name: keyof IEdgeLineOptions): boolean => name !== 'borderDash',\n  };\n}\n\ndeclare module 'chart.js' {\n  export interface ElementOptionsByType<TType extends ChartType> {\n    edgeLine: ScriptableAndArrayOptions<IEdgeLineOptions, ScriptableContext<TType>>;\n  }\n}\n","function interpolateNumber(from: number, to: number, factor: number) {\n  if (from === to) {\n    return to;\n  }\n  return from + (to - from) * factor;\n}\n\nfunction interpolatorPoint(fromArray: any, i: number, to: { x: number; y: number; angle: number }, factor: number) {\n  const from = fromArray[i] || fromArray[i - 1] || fromArray._source;\n  if (!from) {\n    return to;\n  }\n  const x = interpolateNumber(from.x, to.x, factor);\n  const y = interpolateNumber(from.y, to.y, factor);\n  const angle = Number.isNaN(from.angle) ? interpolateNumber(from.angle, to.angle, factor) : undefined;\n  return { x, y, angle };\n}\n\nexport default function interpolatePoints(\n  from: { x: number; y: number; angle: number }[],\n  to: { x: number; y: number; angle: number }[],\n  factor: number\n): { x: number; y: number; angle?: number }[] {\n  if (Array.isArray(from) && Array.isArray(to) && to.length > 0) {\n    return to.map((t, i) => interpolatorPoint(from, i, t, factor));\n  }\n  return to;\n}\n","import { registry, DatasetControllerChartComponent, ChartComponent } from 'chart.js';\n\nexport default function patchController<T, TYPE>(\n  type: TYPE,\n  config: T,\n  controller: DatasetControllerChartComponent,\n  elements: ChartComponent | ChartComponent[] = [],\n  scales: ChartComponent | ChartComponent[] = []\n): T & { type: TYPE } {\n  registry.addControllers(controller);\n  if (Array.isArray(elements)) {\n    registry.addElements(...elements);\n  } else {\n    registry.addElements(elements);\n  }\n  if (Array.isArray(scales)) {\n    registry.addScales(...scales);\n  } else {\n    registry.addScales(scales);\n  }\n  const c = config as any;\n  c.type = type;\n  return c;\n}\n","import {\n  defaults,\n  Chart,\n  ScatterController,\n  registry,\n  LinearScale,\n  PointElement,\n  UpdateMode,\n  TooltipItem,\n  ChartItem,\n  ChartConfiguration,\n  ControllerDatasetOptions,\n  ScriptableAndArrayOptions,\n  LineHoverOptions,\n  PointPrefixedOptions,\n  PointPrefixedHoverOptions,\n  ScriptableContext,\n  Element,\n  CartesianScaleTypeRegistry,\n  CoreChartOptions,\n} from 'chart.js';\nimport { merge, clipArea, unclipArea, listenArrayEvents, unlistenArrayEvents } from 'chart.js/helpers';\nimport { EdgeLine, IEdgeLineOptions } from '../elements';\nimport interpolatePoints from './interpolatePoints';\nimport patchController from './patchController';\n\nexport type AnyObject = Record<string, unknown>;\n\nexport interface IExtendedChartMeta {\n  edges: EdgeLine[];\n  _parsedEdges: ITreeEdge[];\n}\n\nexport interface ITreeNode extends IGraphDataPoint {\n  x: number;\n  y: number;\n  index?: number;\n}\n\nexport interface ITreeEdge {\n  source: number;\n  target: number;\n  points?: { x: number; y: number }[];\n}\n\nexport class GraphController extends ScatterController {\n  /**\n   * @hidden\n   */\n  declare _ctx: CanvasRenderingContext2D;\n\n  /**\n   * @hidden\n   */\n  declare _cachedDataOpts: any;\n\n  /**\n   * @hidden\n   */\n  declare _type: string;\n\n  /**\n   * @hidden\n   */\n  declare _data: any[];\n\n  /**\n   * @hidden\n   */\n  declare _edges: any[];\n\n  /**\n   * @hidden\n   */\n  declare _sharedOptions: any;\n\n  /**\n   * @hidden\n   */\n  declare _edgeSharedOptions: any;\n\n  /**\n   * @hidden\n   */\n  declare dataElementType: any;\n\n  /**\n   * @hidden\n   */\n  private _scheduleResyncLayoutId = -1;\n\n  /**\n   * @hidden\n   */\n  edgeElementType: any;\n\n  /**\n   * @hidden\n   */\n  private readonly _edgeListener = {\n    _onDataPush: (...args: any[]) => {\n      const count = args.length;\n      const start = (this.getDataset() as any).edges.length - count;\n      const parsed = (this._cachedMeta as unknown as IExtendedChartMeta)._parsedEdges;\n      args.forEach((edge) => {\n        parsed.push(this._parseDefinedEdge(edge));\n      });\n      this._insertEdgeElements(start, count);\n    },\n    _onDataPop: () => {\n      (this._cachedMeta as unknown as IExtendedChartMeta).edges.pop();\n      (this._cachedMeta as unknown as IExtendedChartMeta)._parsedEdges.pop();\n      this._scheduleResyncLayout();\n    },\n    _onDataShift: () => {\n      (this._cachedMeta as unknown as IExtendedChartMeta).edges.shift();\n      (this._cachedMeta as unknown as IExtendedChartMeta)._parsedEdges.shift();\n      this._scheduleResyncLayout();\n    },\n    _onDataSplice: (start: number, count: number, ...args: any[]) => {\n      (this._cachedMeta as unknown as IExtendedChartMeta).edges.splice(start, count);\n      (this._cachedMeta as unknown as IExtendedChartMeta)._parsedEdges.splice(start, count);\n      if (args.length > 0) {\n        const parsed = (this._cachedMeta as unknown as IExtendedChartMeta)._parsedEdges;\n        parsed.splice(start, 0, ...args.map((edge) => this._parseDefinedEdge(edge)));\n        this._insertEdgeElements(start, args.length);\n      } else {\n        this._scheduleResyncLayout();\n      }\n    },\n    _onDataUnshift: (...args: any[]) => {\n      const parsed = (this._cachedMeta as unknown as IExtendedChartMeta)._parsedEdges;\n      parsed.unshift(...args.map((edge) => this._parseDefinedEdge(edge)));\n      this._insertEdgeElements(0, args.length);\n    },\n  };\n\n  /**\n   * @hidden\n   */\n  initialize(): void {\n    const type = this._type;\n    const defaultConfig = defaults.datasets[type as 'graph'] as any;\n    this.edgeElementType = registry.getElement(defaultConfig.edgeElementType as string);\n    super.initialize();\n    this.enableOptionSharing = true;\n    this._scheduleResyncLayout();\n  }\n\n  /**\n   * @hidden\n   */\n  parse(start: number, count: number): void {\n    const meta = this._cachedMeta;\n    const data = this._data;\n    const { iScale, vScale } = meta;\n    for (let i = 0; i < count; i += 1) {\n      const index = i + start;\n      const d = data[index];\n      const v = (meta._parsed[index] || {}) as { x: number; y: number };\n      if (d && typeof d.x === 'number') {\n        v.x = d.x;\n      }\n      if (d && typeof d.y === 'number') {\n        v.y = d.y;\n      }\n      meta._parsed[index] = v;\n    }\n    if (meta._parsed.length > data.length) {\n      meta._parsed.splice(data.length, meta._parsed.length - data.length);\n    }\n    this._cachedMeta._sorted = false;\n    (iScale as any)._dataLimitsCached = false;\n    (vScale as any)._dataLimitsCached = false;\n\n    this._parseEdges();\n  }\n\n  /**\n   * @hidden\n   */\n  reset(): void {\n    this.resetLayout();\n    super.reset();\n  }\n\n  /**\n   * @hidden\n   */\n  update(mode: UpdateMode): void {\n    super.update(mode);\n\n    const meta = this._cachedMeta as unknown as IExtendedChartMeta;\n    const edges = meta.edges || [];\n\n    this.updateEdgeElements(edges, 0, mode);\n  }\n\n  /**\n   * @hidden\n   */\n  _destroy(): void {\n    (ScatterController.prototype as any)._destroy.call(this);\n    if (this._edges) {\n      unlistenArrayEvents(this._edges, this._edgeListener);\n    }\n    this.stopLayout();\n  }\n\n  declare getContext: (index: number, active: boolean, mode: UpdateMode) => unknown;\n\n  /**\n   * @hidden\n   */\n  updateEdgeElements(edges: EdgeLine[], start: number, mode: UpdateMode): void {\n    const bak = {\n      _cachedDataOpts: this._cachedDataOpts,\n      dataElementType: this.dataElementType,\n      _sharedOptions: this._sharedOptions,\n      // getDataset: this.getDataset,\n      // getParsed: this.getParsed,\n    };\n    this._cachedDataOpts = {};\n    this.dataElementType = this.edgeElementType;\n    this._sharedOptions = this._edgeSharedOptions;\n\n    const dataset = this.getDataset();\n    const meta = this._cachedMeta;\n    const nodeElements = meta.data;\n    const data = (this._cachedMeta as unknown as IExtendedChartMeta)._parsedEdges;\n\n    // get generic context to prefill cache\n    this.getContext(-1, false, mode);\n    this.getDataset = () => {\n      return new Proxy(dataset, {\n        get(obj: any, prop: string) {\n          return prop === 'data' ? (obj.edges ?? []) : obj[prop];\n        },\n      });\n    };\n    this.getParsed = (index: number) => {\n      return data[index] as any;\n    };\n    // patch meta to store edges\n    meta.data = (meta as any).edges;\n\n    const reset = mode === 'reset';\n\n    const firstOpts = this.resolveDataElementOptions(start, mode);\n    const dummyShared = {};\n    const sharedOptions = this.getSharedOptions(firstOpts) ?? dummyShared;\n    const includeOptions = this.includeOptions(mode, sharedOptions);\n\n    const { xScale, yScale } = meta;\n\n    const base = {\n      x: xScale?.getBasePixel() ?? 0,\n      y: yScale?.getBasePixel() ?? 0,\n    };\n\n    function copyPoint(point: { x: number; y: number; angle?: number }) {\n      const x = reset ? base.x : (xScale?.getPixelForValue(point.x, 0) ?? 0);\n      const y = reset ? base.y : (yScale?.getPixelForValue(point.y, 0) ?? 0);\n      return {\n        x,\n        y,\n        angle: point.angle,\n      };\n    }\n\n    for (let i = 0; i < edges.length; i += 1) {\n      const edge = edges[i];\n      const index = start + i;\n      const parsed = data[index];\n\n      const properties: any = {\n        source: nodeElements[parsed.source],\n        target: nodeElements[parsed.target],\n        points: Array.isArray(parsed.points) ? parsed.points.map((p) => copyPoint(p)) : [],\n      };\n      properties.points._source = nodeElements[parsed.source];\n      if (includeOptions) {\n        if (sharedOptions !== dummyShared) {\n          properties.options = sharedOptions;\n        } else {\n          properties.options = this.resolveDataElementOptions(index, mode);\n        }\n      }\n      this.updateEdgeElement(edge, index, properties, mode);\n    }\n    this.updateSharedOptions(sharedOptions, mode, firstOpts);\n\n    this._edgeSharedOptions = this._sharedOptions;\n    Object.assign(this, bak);\n    delete (this as any).getDataset;\n    delete (this as any).getParsed;\n    // patch meta to store edges\n    meta.data = nodeElements;\n  }\n\n  /**\n   * @hidden\n   */\n\n  updateEdgeElement(edge: EdgeLine, index: number, properties: any, mode: UpdateMode): void {\n    super.updateElement(edge as unknown as Element<AnyObject, AnyObject>, index, properties, mode);\n  }\n\n  /**\n   * @hidden\n   */\n\n  updateElement(point: Element<AnyObject, AnyObject>, index: number, properties: any, mode: UpdateMode): void {\n    if (mode === 'reset') {\n      // start in center also in x\n      const { xScale } = this._cachedMeta;\n\n      properties.x = xScale?.getBasePixel() ?? 0;\n    }\n    super.updateElement(point, index, properties, mode);\n  }\n\n  /**\n   * @hidden\n   */\n  resolveNodeIndex(nodes: any[], ref: string | number | any): number {\n    if (typeof ref === 'number') {\n      // index\n      return ref;\n    }\n    if (typeof ref === 'string') {\n      // label\n      const labels = this.chart.data.labels as string[];\n      return labels.indexOf(ref);\n    }\n    const nIndex = nodes.indexOf(ref);\n    if (nIndex >= 0) {\n      // hit\n      return nIndex;\n    }\n\n    const data = this.getDataset().data as any[];\n    const index = data.indexOf(ref);\n    if (index >= 0) {\n      return index;\n    }\n\n    console.warn('cannot resolve edge ref', ref);\n    return -1;\n  }\n\n  /**\n   * @hidden\n   */\n  buildOrUpdateElements(): void {\n    const dataset = this.getDataset() as any;\n    const edges = dataset.edges || [];\n\n    // In order to correctly handle data addition/deletion animation (an thus simulate\n    // real-time charts), we need to monitor these data modifications and synchronize\n    // the internal meta data accordingly.\n    if (this._edges !== edges) {\n      if (this._edges) {\n        // This case happens when the user replaced the data array instance.\n        unlistenArrayEvents(this._edges, this._edgeListener);\n      }\n\n      if (edges && Object.isExtensible(edges)) {\n        listenArrayEvents(edges, this._edgeListener);\n      }\n      this._edges = edges;\n    }\n    super.buildOrUpdateElements();\n  }\n\n  /**\n   * @hidden\n   */\n  draw(): void {\n    const meta = this._cachedMeta;\n    const edges = (this._cachedMeta as unknown as IExtendedChartMeta).edges || [];\n    const elements = (meta.data || []) as unknown[] as PointElement[];\n\n    const area = this.chart.chartArea;\n    const ctx = this._ctx;\n\n    if (edges.length > 0) {\n      clipArea(ctx, area);\n      edges.forEach((edge) => (edge.draw.call as any)(edge, ctx, area));\n      unclipArea(ctx);\n    }\n\n    elements.forEach((elem) => (elem.draw.call as any)(elem, ctx, area));\n  }\n\n  protected _resyncElements(): void {\n    (ScatterController.prototype as any)._resyncElements.call(this);\n\n    const meta = this._cachedMeta as unknown as IExtendedChartMeta;\n    const edges = meta._parsedEdges;\n    const metaEdges = meta.edges || (meta.edges = []);\n    const numMeta = metaEdges.length;\n    const numData = edges.length;\n\n    if (numData < numMeta) {\n      metaEdges.splice(numData, numMeta - numData);\n      this._scheduleResyncLayout();\n    } else if (numData > numMeta) {\n      this._insertEdgeElements(numMeta, numData - numMeta);\n    }\n  }\n\n  getTreeRootIndex(): number {\n    const ds = this.getDataset() as any;\n    const nodes = ds.data as any[];\n    if (ds.derivedEdges) {\n      // find the one with no parent\n      return nodes.findIndex((d) => d.parent == null);\n    }\n    // find the one with no edge\n    const edges = (this._cachedMeta as unknown as IExtendedChartMeta)._parsedEdges || [];\n    const nodeIndices = new Set(nodes.map((_, i) => i));\n    edges.forEach((edge) => {\n      nodeIndices.delete(edge.target);\n    });\n    return Array.from(nodeIndices)[0];\n  }\n\n  getTreeRoot(): ITreeNode {\n    const index = this.getTreeRootIndex();\n    const p = this.getParsed(index) as ITreeNode;\n    p.index = index;\n    return p;\n  }\n\n  getTreeChildren(node: { index?: number }): ITreeNode[] {\n    const edges = (this._cachedMeta as unknown as IExtendedChartMeta)._parsedEdges;\n    const index = node.index ?? 0;\n    return edges\n      .filter((d) => d.source === index)\n      .map((d) => {\n        const p = this.getParsed(d.target) as ITreeNode;\n        p.index = d.target;\n        return p;\n      });\n  }\n\n  /**\n   * @hidden\n   */\n  _parseDefinedEdge(edge: { source: number; target: number }): ITreeEdge {\n    const ds = this.getDataset();\n    const { data } = ds;\n    return {\n      source: this.resolveNodeIndex(data, edge.source),\n      target: this.resolveNodeIndex(data, edge.target),\n      points: [],\n    };\n  }\n\n  /**\n   * @hidden\n   */\n  _parseEdges(): ITreeEdge[] {\n    const ds = this.getDataset() as any;\n    const data = ds.data as { parent?: number }[];\n    const meta = this._cachedMeta as unknown as IExtendedChartMeta;\n    if (ds.edges) {\n      const edges = ds.edges.map((edge: any) => this._parseDefinedEdge(edge));\n      meta._parsedEdges = edges;\n      return edges;\n    }\n\n    const edges: ITreeEdge[] = [];\n    meta._parsedEdges = edges as any;\n    // try to derive edges via parent links\n    data.forEach((node, i) => {\n      if (node.parent != null) {\n        // tree edge\n        const parent = this.resolveNodeIndex(data, node.parent);\n        edges.push({\n          source: parent,\n          target: i,\n          points: [],\n        });\n      }\n    });\n    return edges;\n  }\n\n  /**\n   * @hidden\n   */\n  addElements(): void {\n    super.addElements();\n\n    const meta = this._cachedMeta as unknown as IExtendedChartMeta;\n    const edges = this._parseEdges();\n    const metaData = new Array(edges.length);\n    meta.edges = metaData;\n\n    for (let i = 0; i < edges.length; i += 1) {\n      metaData[i] = new this.edgeElementType();\n    }\n  }\n\n  /**\n   * @hidden\n   */\n  _resyncEdgeElements(): void {\n    const meta = this._cachedMeta as unknown as IExtendedChartMeta;\n    const edges = this._parseEdges();\n    const metaData = meta.edges || (meta.edges = []);\n\n    for (let i = 0; i < edges.length; i += 1) {\n      metaData[i] = metaData[i] || new this.edgeElementType();\n    }\n    if (edges.length < metaData.length) {\n      metaData.splice(edges.length, metaData.length);\n    }\n  }\n\n  /**\n   * @hidden\n   */\n  _insertElements(start: number, count: number): void {\n    (ScatterController.prototype as any)._insertElements.call(this, start, count);\n    if (count > 0) {\n      this._resyncEdgeElements();\n    }\n  }\n\n  /**\n   * @hidden\n   */\n  _removeElements(start: number, count: number): void {\n    (ScatterController.prototype as any)._removeElements.call(this, start, count);\n    if (count > 0) {\n      this._resyncEdgeElements();\n    }\n  }\n\n  /**\n   * @hidden\n   */\n  _insertEdgeElements(start: number, count: number): void {\n    const elements = [];\n    for (let i = 0; i < count; i += 1) {\n      elements.push(new this.edgeElementType());\n    }\n    (this._cachedMeta as unknown as IExtendedChartMeta).edges.splice(start, 0, ...elements);\n    this.updateEdgeElements(elements, start, 'reset');\n    this._scheduleResyncLayout();\n  }\n\n  reLayout(): void {\n    // hook\n  }\n\n  resetLayout(): void {\n    // hook\n  }\n\n  stopLayout(): void {\n    // hook\n  }\n\n  /**\n   * @hidden\n   */\n  _scheduleResyncLayout(): void {\n    if (this._scheduleResyncLayoutId != null && this._scheduleResyncLayoutId >= 0) {\n      return;\n    }\n    this._scheduleResyncLayoutId = requestAnimationFrame(() => {\n      this._scheduleResyncLayoutId = -1;\n      this.resyncLayout();\n    });\n  }\n\n  resyncLayout(): void {\n    // hook\n  }\n\n  static readonly id: string = 'graph';\n\n  /**\n   * @hidden\n   */\n  static readonly defaults: any = /* #__PURE__ */ merge({}, [\n    ScatterController.defaults,\n    {\n      clip: 10, // some space in combination with padding\n      animations: {\n        points: {\n          fn: interpolatePoints,\n          properties: ['points'],\n        },\n      },\n      edgeElementType: EdgeLine.id,\n    },\n  ]);\n\n  /**\n   * @hidden\n   */\n  static readonly overrides: any = /* #__PURE__ */ merge({}, [\n    (ScatterController as any).overrides,\n    {\n      layout: {\n        padding: 10,\n      },\n      scales: {\n        x: {\n          display: false,\n          ticks: {\n            maxTicksLimit: 2,\n            precision: 100,\n            minRotation: 0,\n            maxRotation: 0,\n          },\n        },\n        y: {\n          display: false,\n          ticks: {\n            maxTicksLimit: 2,\n            precision: 100,\n            minRotation: 0,\n            maxRotation: 0,\n          },\n        },\n      },\n      plugins: {\n        tooltip: {\n          callbacks: {\n            label(item: TooltipItem<'graph'>) {\n              return item.chart.data?.labels?.[item.dataIndex];\n            },\n          },\n        },\n      },\n    },\n  ]);\n}\n\nexport interface IGraphDataPoint {\n  parent?: number;\n}\n\nexport interface IGraphEdgeDataPoint {\n  source: number | string;\n  target: number | string;\n}\n\nexport interface IGraphChartControllerDatasetOptions\n  extends ControllerDatasetOptions,\n    ScriptableAndArrayOptions<PointPrefixedOptions, ScriptableContext<'graph'>>,\n    ScriptableAndArrayOptions<PointPrefixedHoverOptions, ScriptableContext<'graph'>>,\n    ScriptableAndArrayOptions<IEdgeLineOptions, ScriptableContext<'graph'>>,\n    ScriptableAndArrayOptions<LineHoverOptions, ScriptableContext<'graph'>> {\n  edges: IGraphEdgeDataPoint[];\n}\n\ndeclare module 'chart.js' {\n  export interface ChartTypeRegistry {\n    graph: {\n      chartOptions: CoreChartOptions<'graph'>;\n      datasetOptions: IGraphChartControllerDatasetOptions;\n      defaultDataPoint: IGraphDataPoint;\n      metaExtensions: Record<string, never>;\n      parsedDataType: ITreeNode;\n      scales: keyof CartesianScaleTypeRegistry;\n    };\n  }\n}\n\nexport class GraphChart<DATA extends unknown[] = IGraphDataPoint[], LABEL = string> extends Chart<\n  'graph',\n  DATA,\n  LABEL\n> {\n  static id = GraphController.id;\n\n  constructor(item: ChartItem, config: Omit<ChartConfiguration<'graph', DATA, LABEL>, 'type'>) {\n    super(item, patchController('graph', config, GraphController, [EdgeLine, PointElement], LinearScale));\n  }\n}\n","import {\n  Chart,\n  ChartItem,\n  ChartConfiguration,\n  LinearScale,\n  PointElement,\n  CoreChartOptions,\n  CartesianScaleTypeRegistry,\n} from 'chart.js';\nimport { merge } from 'chart.js/helpers';\nimport {\n  forceCenter,\n  forceCollide,\n  forceLink,\n  ForceLink,\n  forceManyBody,\n  forceRadial,\n  forceSimulation,\n  forceX,\n  forceY,\n  Simulation,\n  SimulationLinkDatum,\n  SimulationNodeDatum,\n} from 'd3-force';\nimport { EdgeLine } from '../elements';\nimport {\n  GraphController,\n  IGraphChartControllerDatasetOptions,\n  IGraphDataPoint,\n  ITreeNode,\n  IExtendedChartMeta,\n} from './GraphController';\nimport patchController from './patchController';\n\nexport interface ITreeSimNode extends ITreeNode {\n  _sim: { x?: number; y?: number; vx?: number; vy?: number; index?: number };\n  reset?: boolean;\n}\n\nexport interface IForceDirectedControllerOptions {\n  simulation: {\n    /**\n     * auto restarts the simulation upon dataset change, one can manually restart by calling: `chart.getDatasetMeta(0).controller.reLayout();`\n     *\n     * @default true\n     */\n    autoRestart: boolean;\n\n    initialIterations: number;\n\n    forces: {\n      /**\n       * center force\n       * https://github.com/d3/d3-force/#centering\n       *\n       * @default true\n       */\n      center: boolean | ICenterForce;\n\n      /**\n       * collision between nodes\n       * https://github.com/d3/d3-force/#collision\n       *\n       * @default false\n       */\n      collide: boolean | ICollideForce;\n\n      /**\n       * link force\n       * https://github.com/d3/d3-force/#links\n       *\n       * @default true\n       */\n      link: boolean | ILinkForce;\n\n      /**\n       * link force\n       * https://github.com/d3/d3-force/#many-body\n       *\n       * @default true\n       */\n      manyBody: boolean | IManyBodyForce;\n\n      /**\n       * x positioning force\n       * https://github.com/d3/d3-force/#forceX\n       *\n       * @default false\n       */\n      x: boolean | IForceXForce;\n\n      /**\n       * y positioning force\n       * https://github.com/d3/d3-force/#forceY\n       *\n       * @default false\n       */\n      y: boolean | IForceYForce;\n\n      /**\n       * radial positioning force\n       * https://github.com/d3/d3-force/#forceRadial\n       *\n       * @default false\n       */\n      radial: boolean | IRadialForce;\n    };\n  };\n}\n\nexport declare type ID3NodeCallback = (d: any, i: number) => number;\nexport declare type ID3EdgeCallback = (d: any, i: number) => number;\n\nexport interface ICenterForce {\n  x?: number;\n  y?: number;\n}\n\nexport interface ICollideForce {\n  radius?: number | ID3NodeCallback;\n  strength?: number | ID3NodeCallback;\n}\n\nexport interface ILinkForce {\n  id?: (d: { source: any; target: any }) => string | number;\n  distance?: number | ID3EdgeCallback;\n  strength?: number | ID3EdgeCallback;\n}\n\nexport interface IManyBodyForce {\n  strength?: number | ID3NodeCallback;\n  theta?: number;\n  distanceMin?: number;\n  distanceMax?: number;\n}\n\nexport interface IForceXForce {\n  x?: number;\n  strength?: number;\n}\n\nexport interface IForceYForce {\n  y?: number;\n  strength?: number;\n}\n\nexport interface IRadialForce {\n  x?: number;\n  y?: number;\n  radius?: number;\n  strength?: number;\n}\n\nexport class ForceDirectedGraphController extends GraphController {\n  /**\n   * @hidden\n   */\n  declare options: IForceDirectedControllerOptions;\n\n  /**\n   * @hidden\n   */\n  private readonly _simulation: Simulation<SimulationNodeDatum, undefined>;\n\n  private _animTimer: number = -1;\n\n  constructor(chart: Chart, datasetIndex: number) {\n    super(chart, datasetIndex);\n    this._simulation = forceSimulation()\n      .on('tick', () => {\n        if (this.chart.canvas && this._animTimer !== -2) {\n          this._copyPosition();\n          this.chart.render();\n        } else {\n          this._simulation.stop();\n        }\n      })\n      .on('end', () => {\n        if (this.chart.canvas && this._animTimer !== -2) {\n          this._copyPosition();\n          this.chart.render();\n          // trigger a full update\n          this.chart.update('default');\n        }\n      });\n    const sim = this.options.simulation;\n\n    const fs = {\n      center: forceCenter,\n      collide: forceCollide,\n      link: forceLink,\n      manyBody: forceManyBody,\n      x: forceX,\n      y: forceY,\n      radial: forceRadial,\n    };\n\n    (Object.keys(fs) as (keyof typeof fs)[]).forEach((key) => {\n      const options = sim.forces[key] as any;\n      if (!options) {\n        return;\n      }\n      const f = (fs[key] as any)();\n      if (typeof options !== 'boolean') {\n        Object.keys(options).forEach((attr) => {\n          f[attr](options[attr]);\n        });\n      }\n      this._simulation.force(key, f);\n    });\n    this._simulation.stop();\n  }\n\n  _destroy() {\n    if (this._animTimer >= 0) {\n      cancelAnimationFrame(this._animTimer);\n    }\n    this._animTimer = -2;\n    return super._destroy();\n  }\n\n  /**\n   * @hidden\n   */\n  _copyPosition(): void {\n    const nodes = this._cachedMeta._parsed as ITreeSimNode[];\n\n    const minmax = nodes.reduce(\n      (acc, v) => {\n        const s = v._sim;\n        if (!s || s.x == null || s.y == null) {\n          return acc;\n        }\n        if (s.x < acc.minX) {\n          acc.minX = s.x;\n        }\n        if (s.x > acc.maxX) {\n          acc.maxX = s.x;\n        }\n        if (s.y < acc.minY) {\n          acc.minY = s.y;\n        }\n        if (s.y > acc.maxY) {\n          acc.maxY = s.y;\n        }\n        return acc;\n      },\n      {\n        minX: Number.POSITIVE_INFINITY,\n        maxX: Number.NEGATIVE_INFINITY,\n        minY: Number.POSITIVE_INFINITY,\n        maxY: Number.NEGATIVE_INFINITY,\n      }\n    );\n\n    const rescaleX = (v: number) => ((v - minmax.minX) / (minmax.maxX - minmax.minX)) * 2 - 1;\n    const rescaleY = (v: number) => ((v - minmax.minY) / (minmax.maxY - minmax.minY)) * 2 - 1;\n\n    nodes.forEach((node) => {\n      if (node._sim) {\n        node.x = rescaleX(node._sim.x ?? 0);\n\n        node.y = rescaleY(node._sim.y ?? 0);\n      }\n    });\n\n    const { xScale, yScale } = this._cachedMeta;\n    const elems = this._cachedMeta.data;\n    elems.forEach((elem, i) => {\n      const parsed = nodes[i];\n      Object.assign(elem, {\n        x: xScale?.getPixelForValue(parsed.x, i) ?? 0,\n        y: yScale?.getPixelForValue(parsed.y, i) ?? 0,\n        skip: false,\n      });\n    });\n  }\n\n  resetLayout(): void {\n    super.resetLayout();\n    this._simulation.stop();\n\n    const nodes = (this._cachedMeta._parsed as ITreeSimNode[]).map((node, i) => {\n      const simNode: ITreeSimNode['_sim'] = { ...node };\n      simNode.index = i;\n\n      node._sim = simNode;\n      if (!node.reset) {\n        return simNode;\n      }\n      delete simNode.x;\n      delete simNode.y;\n      delete simNode.vx;\n      delete simNode.vy;\n      return simNode;\n    });\n    this._simulation.nodes(nodes);\n    this._simulation.alpha(1).restart();\n  }\n\n  resyncLayout(): void {\n    super.resyncLayout();\n    this._simulation.stop();\n\n    const meta = this._cachedMeta;\n\n    const nodes = (meta._parsed as ITreeSimNode[]).map((node, i) => {\n      const simNode: ITreeSimNode['_sim'] = { ...node };\n      simNode.index = i;\n\n      node._sim = simNode;\n      if (simNode.x === null) {\n        delete simNode.x;\n      }\n      if (simNode.y === null) {\n        delete simNode.y;\n      }\n      if (simNode.x == null && simNode.y == null) {\n        node.reset = true;\n      }\n      return simNode;\n    });\n    const link =\n      this._simulation.force<ForceLink<SimulationNodeDatum, SimulationLinkDatum<SimulationNodeDatum>>>('link');\n    if (link) {\n      link.links([]);\n    }\n    this._simulation.nodes(nodes);\n    if (link) {\n      // console.assert(ds.edges.length === meta.edges.length);\n      // work on copy to avoid change\n      link.links(((meta as unknown as IExtendedChartMeta)._parsedEdges || []).map((l) => ({ ...l })));\n    }\n\n    if (this.options.simulation.initialIterations > 0) {\n      this._simulation.alpha(1);\n      this._simulation.tick(this.options.simulation.initialIterations);\n      this._copyPosition();\n      if (this.options.simulation.autoRestart) {\n        this._simulation.restart();\n      } else if (this.chart.canvas != null && this._animTimer !== -2) {\n        const chart = this.chart;\n        this._animTimer = requestAnimationFrame(() => {\n          if (chart.canvas) {\n            chart.update();\n          }\n        });\n      }\n    } else if (this.options.simulation.autoRestart && this.chart.canvas != null && this._animTimer !== -2) {\n      this._simulation.alpha(1).restart();\n    }\n  }\n\n  reLayout(): void {\n    this._simulation.alpha(1).restart();\n  }\n\n  stopLayout(): void {\n    super.stopLayout();\n    this._simulation.stop();\n  }\n\n  static readonly id = 'forceDirectedGraph';\n\n  /**\n   * @hidden\n   */\n  static readonly defaults: any = /* #__PURE__ */ merge({}, [\n    GraphController.defaults,\n    {\n      animation: false,\n      simulation: {\n        initialIterations: 0,\n        autoRestart: true,\n        forces: {\n          center: true,\n          collide: false,\n          link: true,\n          manyBody: true,\n          x: false,\n          y: false,\n          radial: false,\n        },\n      },\n    },\n  ]);\n\n  /**\n   * @hidden\n   */\n  static readonly overrides: any = /* #__PURE__ */ merge({}, [\n    GraphController.overrides,\n    {\n      scales: {\n        x: {\n          min: -1,\n          max: 1,\n        },\n        y: {\n          min: -1,\n          max: 1,\n        },\n      },\n    },\n  ]);\n}\n\nexport interface IForceDirectedGraphChartControllerDatasetOptions\n  extends IGraphChartControllerDatasetOptions,\n    IForceDirectedControllerOptions {}\n\ndeclare module 'chart.js' {\n  export interface ChartTypeRegistry {\n    forceDirectedGraph: {\n      chartOptions: CoreChartOptions<'forceDirectedGraph'> & IForceDirectedControllerOptions;\n      datasetOptions: IForceDirectedGraphChartControllerDatasetOptions;\n      defaultDataPoint: IGraphDataPoint & Record<string, unknown>;\n      metaExtensions: Record<string, never>;\n      parsedDataType: ITreeSimNode;\n      scales: keyof CartesianScaleTypeRegistry;\n    };\n  }\n}\n\nexport class ForceDirectedGraphChart<DATA extends unknown[] = IGraphDataPoint[], LABEL = string> extends Chart<\n  'forceDirectedGraph',\n  DATA,\n  LABEL\n> {\n  static id = ForceDirectedGraphController.id;\n\n  constructor(item: ChartItem, config: Omit<ChartConfiguration<'forceDirectedGraph', DATA, LABEL>, 'type'>) {\n    super(\n      item,\n      patchController('forceDirectedGraph', config, ForceDirectedGraphController, [EdgeLine, PointElement], LinearScale)\n    );\n  }\n}\n","import {\n  Chart,\n  ChartItem,\n  ChartConfiguration,\n  LinearScale,\n  PointElement,\n  UpdateMode,\n  Element,\n  CartesianScaleTypeRegistry,\n  CoreChartOptions,\n} from 'chart.js';\nimport { merge } from 'chart.js/helpers';\nimport { cluster, hierarchy, HierarchyNode, tree } from 'd3-hierarchy';\nimport { EdgeLine } from '../elements';\nimport {\n  GraphController,\n  IGraphChartControllerDatasetOptions,\n  IGraphDataPoint,\n  ITreeNode,\n  AnyObject,\n} from './GraphController';\nimport patchController from './patchController';\n\nexport interface ITreeOptions {\n  /**\n   * tree (cluster) or dendrogram layout default depends on the chart type\n   */\n  mode: 'dendrogram' | 'tree' | 'dendrogram';\n  /**\n   * orientation of the tree layout\n   * @default horizontal\n   */\n  orientation: 'horizontal' | 'vertical' | 'radial';\n}\n\nexport class DendrogramController extends GraphController {\n  /**\n   * @hidden\n   */\n  declare options: { tree: ITreeOptions };\n\n  private _animTimer: number = -1;\n\n  /**\n   * @hidden\n   */\n\n  updateEdgeElement(line: EdgeLine, index: number, properties: any, mode: UpdateMode): void {\n    properties._orientation = this.options.tree.orientation;\n    super.updateEdgeElement(line, index, properties, mode);\n  }\n\n  _destroy() {\n    if (this._animTimer >= 0) {\n      cancelAnimationFrame(this._animTimer);\n    }\n    this._animTimer = -2;\n    return super._destroy();\n  }\n\n  /**\n   * @hidden\n   */\n\n  updateElement(point: Element<AnyObject, AnyObject>, index: number, properties: any, mode: UpdateMode): void {\n    if (index != null) {\n      properties.angle = (this.getParsed(index) as { angle: number }).angle;\n    }\n    super.updateElement(point, index, properties, mode);\n  }\n\n  resyncLayout(): void {\n    const meta = this._cachedMeta as any;\n\n    meta.root = hierarchy(this.getTreeRoot(), (d) => this.getTreeChildren(d))\n      .count()\n      .sort((a, b) => b.height - a.height || (b.data.index ?? 0) - (a.data.index ?? 0));\n\n    this.doLayout(meta.root);\n\n    super.resyncLayout();\n  }\n\n  reLayout(newOptions: Partial<ITreeOptions> = {}): void {\n    if (newOptions) {\n      Object.assign(this.options.tree, newOptions);\n      const ds = this.getDataset() as any;\n      if (ds.tree) {\n        Object.assign(ds.tree, newOptions);\n      } else {\n        ds.tree = newOptions;\n      }\n    }\n    this.doLayout((this._cachedMeta as any).root);\n  }\n\n  doLayout(root: HierarchyNode<{ x: number; y: number; angle?: number }>): void {\n    const options = this.options.tree;\n\n    const layout =\n      options.mode === 'tree'\n        ? tree<{ x: number; y: number; angle?: number }>()\n        : cluster<{ x: number; y: number; angle?: number }>();\n\n    if (options.orientation === 'radial') {\n      layout.size([Math.PI * 2, 1]);\n    } else {\n      layout.size([2, 2]);\n    }\n\n    const orientation = {\n      horizontal: (d: { x: number; y: number; data: { x: number; y: number } }) => {\n        d.data.x = d.y - 1;\n\n        d.data.y = -d.x + 1;\n      },\n      vertical: (d: { x: number; y: number; data: { x: number; y: number } }) => {\n        d.data.x = d.x - 1;\n\n        d.data.y = -d.y + 1;\n      },\n      radial: (d: { x: number; y: number; data: { x: number; y: number; angle?: number } }) => {\n        d.data.x = Math.cos(d.x) * d.y;\n\n        d.data.y = Math.sin(d.x) * d.y;\n\n        d.data.angle = d.y === 0 ? Number.NaN : d.x;\n      },\n    };\n\n    layout(root).each((orientation[options.orientation] || orientation.horizontal) as any);\n\n    const chart = this.chart;\n    if (this._animTimer !== -2) {\n      this._animTimer = requestAnimationFrame(() => {\n        if (chart.canvas) {\n          chart.update();\n        }\n      });\n    }\n  }\n\n  static readonly id: string = 'dendrogram';\n\n  /**\n   * @hidden\n   */\n  static readonly defaults: any = /* #__PURE__ */ merge({}, [\n    GraphController.defaults,\n    {\n      tree: {\n        mode: 'dendrogram', // dendrogram, tree\n        orientation: 'horizontal', // vertical, horizontal, radial\n      },\n      animations: {\n        numbers: {\n          type: 'number',\n          properties: ['x', 'y', 'angle', 'radius', 'rotation', 'borderWidth'],\n        },\n      },\n      tension: 0.4,\n    },\n  ]);\n\n  /**\n   * @hidden\n   */\n  static readonly overrides: any = /* #__PURE__ */ merge({}, [\n    GraphController.overrides,\n    {\n      scales: {\n        x: {\n          min: -1,\n          max: 1,\n        },\n        y: {\n          min: -1,\n          max: 1,\n        },\n      },\n    },\n  ]);\n}\n\nexport interface IDendrogramChartControllerDatasetOptions extends IGraphChartControllerDatasetOptions {\n  tree: ITreeOptions;\n}\n\ndeclare module 'chart.js' {\n  export interface ChartTypeRegistry {\n    dendogram: {\n      chartOptions: CoreChartOptions<'dendrogram'> & { tree: ITreeOptions };\n      datasetOptions: IDendrogramChartControllerDatasetOptions;\n      defaultDataPoint: IGraphDataPoint & Record<string, unknown>;\n      metaExtensions: Record<string, never>;\n      parsedDataType: ITreeNode & { angle?: number };\n      scales: keyof CartesianScaleTypeRegistry;\n    };\n    dendrogram: {\n      chartOptions: CoreChartOptions<'dendrogram'> & { tree: ITreeOptions };\n      datasetOptions: IDendrogramChartControllerDatasetOptions;\n      defaultDataPoint: IGraphDataPoint & Record<string, unknown>;\n      metaExtensions: Record<string, never>;\n      parsedDataType: ITreeNode & { angle?: number };\n      scales: keyof CartesianScaleTypeRegistry;\n    };\n  }\n}\n\nexport class DendrogramChart<DATA extends unknown[] = IGraphDataPoint[], LABEL = string> extends Chart<\n  'dendrogram',\n  DATA,\n  LABEL\n> {\n  static id = DendrogramController.id;\n\n  constructor(item: ChartItem, config: Omit<ChartConfiguration<'dendrogram', DATA, LABEL>, 'type'>) {\n    super(item, patchController('dendrogram', config, DendrogramController, [EdgeLine, PointElement], LinearScale));\n  }\n}\n\nexport class DendogramController extends DendrogramController {\n  static readonly id: string = 'dendogram';\n\n  /**\n   * @hidden\n   */\n  static readonly defaults: any = /* #__PURE__ */ merge({}, [\n    DendrogramController.defaults,\n    {\n      tree: {\n        mode: 'dendrogram', // dendrogram, tree\n      },\n    },\n  ]);\n}\n\nexport const DendogramChart = DendrogramChart;\n","import {\n  CartesianScaleTypeRegistry,\n  Chart,\n  ChartConfiguration,\n  ChartItem,\n  CoreChartOptions,\n  LinearScale,\n  PointElement,\n} from 'chart.js';\nimport { merge } from 'chart.js/helpers';\nimport { EdgeLine } from '../elements';\nimport { DendrogramController, IDendrogramChartControllerDatasetOptions, ITreeOptions } from './DendrogramController';\nimport type { IGraphDataPoint, ITreeNode } from './GraphController';\nimport patchController from './patchController';\n\nexport class TreeController extends DendrogramController {\n  static readonly id = 'tree';\n\n  /**\n   * @hidden\n   */\n  static readonly defaults: any = /* #__PURE__ */ merge({}, [\n    DendrogramController.defaults,\n    {\n      tree: {\n        mode: 'tree',\n      },\n    },\n  ]);\n\n  /**\n   * @hidden\n   */\n  static readonly overrides: any = /* #__PURE__ */ DendrogramController.overrides;\n}\n\ndeclare module 'chart.js' {\n  export interface ChartTypeRegistry {\n    tree: {\n      chartOptions: CoreChartOptions<'tree'> & { tree: ITreeOptions };\n      datasetOptions: IDendrogramChartControllerDatasetOptions;\n      defaultDataPoint: IGraphDataPoint & Record<string, unknown>;\n      metaExtensions: Record<string, never>;\n      parsedDataType: ITreeNode;\n      scales: keyof CartesianScaleTypeRegistry;\n    };\n  }\n}\n\nexport class TreeChart<DATA extends unknown[] = IGraphDataPoint[], LABEL = string> extends Chart<'tree', DATA, LABEL> {\n  static id = TreeController.id;\n\n  constructor(item: ChartItem, config: Omit<ChartConfiguration<'tree', DATA, LABEL>, 'type'>) {\n    super(item, patchController('tree', config, TreeController, [EdgeLine, PointElement], LinearScale));\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}